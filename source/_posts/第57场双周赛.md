---
title: 第57场双周赛
author: 小M
img: /medias/2021.7.24.jpg
# coverImg: /medias/banner/7.jpg
top: false
cover: true
toc: true
date: 2021-07-24 15:37:02
tags: Leetcode
summary: 这次双周赛最后一题hard挺简单的，但是差第三题Medium没做出来。下次继续努力~
---
这次周赛最后一题hard挺简单的，但是差第三题Medium没做出来。下次继续努力~
## 第一题(easy)
### [检查是否所有字符出现次数相同](https://leetcode-cn.com/problems/check-if-all-characters-have-equal-number-of-occurrences/)
给你一个字符串s，如果s是一个好字符串，请返回true，否则请返回false。如果s中出现过的所有字符的出现次数相同，那么我们称字符串s是好字符串。s只包含小写英文字符。
没什么好说的，直接哈希一遍
```bash
class Solution {
public:
    bool areOccurrencesEqual(string s) {
        unordered_map<char,int> map;
        for(auto x:s){
            map[x]++;
        }
        int temp=map.begin()->second;
        for(auto x=map.begin();x!=map.end();x++){
            if(temp!=x->second)return false;
        }
        return true;
    }
};
```
当然你也可以不用哈希，定义一个26大小的vector，比较的时候把非零的跳过就行,这样会比哈希表快一些
```bash
class Solution {
public:
    bool areOccurrencesEqual(string s) {
        vector<int> res(26);
        for(auto x:s){
            res[x-'a']++;
        }
        int num=0;
        for(auto x:res){
            if(x){
                if(!num)num=x;
                else if(x!=num)return false;
            num=x;
            }
        }
        return true;
    }
};
```
## 第二题(Medium)
### [最小未被占据椅子的编号](https://leetcode-cn.com/problems/the-number-of-the-smallest-unoccupied-chair/)
有 n 个朋友在举办一个派对，这些朋友从 0 到 n - 1 编号。派对里有 无数 张椅子，编号为 0 到 infinity 。当一个朋友到达派对时，他会占据 编号最小 且未被占据的椅子。
比方说，当一个朋友到达时，如果椅子 0 ，1 和 5 被占据了，那么他会占据 2 号椅子。
当一个朋友离开派对时，他的椅子会立刻变成未占据状态。如果同一时刻有另一个朋友到达，可以立即占据这张椅子。
给你一个下标从 0 开始的二维整数数组 times ，其中 times[i] = [arrivali, leavingi] 表示第i个朋友到达和离开的时刻，同时给你一个整数targetFriend。所有到达时间互不相同 。
请你返回编号为targetFriend的朋友占据的椅子编号。
注意条件就行。题目要求优先占据编号小的椅子。故可以维护一个优先队列，用来存放空着的椅子编号。这题很像leetcode上的[吃苹果的最大数目](https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/)但是要注意的是，吃苹果的这里是每天增加天数的，但是这里朋友离去并不是每一分钟都会有，也不是每分钟都会有朋友过来。所以需要额外维护一个优先队列，用来存储朋友离去的时间。有了思路之后可以写出代码：
```bash
class Solution {
public:
     #define P vector<int>
    int smallestChair(vector<vector<int>>& times, int targetFriend) {
        vector<int> temp=times[targetFriend];
        sort(times.begin(),times.end(),[](auto x,auto y){return x[0]<y[0];});   //先排序，朋友相继过来
        priority_queue<P, vector<P>, greater<P> > save;     #存储朋友离去的时间
        priority_queue<int, vector<int>, greater<int> > my_save;    #储存最空出来的最小位置
        for(int i=0;i<times.size();i++){#初始化凳子
            my_save.push(i);
        }
        int j=0;
        for(int i=0;i<100000;i++){#初始化时间
            while(!save.empty()&&save.top()[0]==i){#如果有朋友离去，将凳子入队，朋友出队
                my_save.push(save.top()[2]);
                save.pop();
            }

            if(j<times.size()&&i==times[j][0]){#如果还有朋友没到，朋友到了分配凳子，并入队
                if(times[j]==temp)return my_save.top();#分配序号最小的凳子
                save.push({times[j][1],times[j][0],my_save.top()});#离去的时间、进来的时间、占据的凳子入队
                my_save.pop();#凳子分配完成，出队
                j++;#朋友减一
            }
        }
      return 0;
    }
};
```

## 第三题(Medium)
### [描述绘画的结果](https://leetcode-cn.com/problems/describe-the-painting/)




## 第四题(Hard)
### [队列中可以看到的人数](https://leetcode-cn.com/problems/number-of-visible-people-in-a-queue/)
有 n 个人排成一个队列，从左到右 编号为 0 到 n - 1 。给你以一个整数数组 heights ，每个整数 互不相同，heights[i] 表示第 i 个人的高度。

一个人能 看到 他右边另一个人的条件是这两人之间的所有人都比他们两人 矮 。更正式的，第 i 个人能看到第 j 个人的条件是 i < j 且 min(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1]) 。
请你返回一个长度为 n 的数组 answer ，其中 answer[i] 是第 i 个人在他右侧队列中能 看到 的 人数 。
![](/medias/57.1.jpg)
很简单的单调栈，其实是送分题，第一次竞赛做出Hard~
思路：其实题目讲的有点不清，就是两个人相邻(指右边相邻)，是肯定能看到的，向左遍历，维护一个递减栈，每次将比nums[i]小的弹出来，弹出来的个数就是向右看到的人的个数
因为向左遍历的时候，弹出的都是比自己小的，能看到的条件约束，比栈顶小的，nums[i]是看不到的，应该将在nums[i-1]进栈(上一次)将其弹出，而比栈顶大的，nums[i]才有机会看到。
```bash
class Solution {
public:
    vector<int> canSeePersonsCount(vector<int>& heights) {
        stack<int> right;
        vector<int> my_r(heights.size(),1);#这里初始化都能看到一个人，即右边相邻的人
        my_r[heights.size()-1]=0;#最后一个人看不到人
        right.push(heights.size()-1);#入栈
        for(int i=heights.size()-2;i>=0;i--){
            int temp=heights[i];
            while(!right.empty()){
                int top=heights[right.top()];
                if(top<=temp){#比自己小就出栈，说明能看到他
                    right.pop();
                    my_r[i]++;#记录弹出多少
                    if(right.empty()){
                        my_r[i]--;#如果将栈弹空说明全都能看见，但是初始化默认能看到一个人，所以要去掉。
                        right.push(i);
                        break;
                    }
                }else{
                    right.push(i);
                    break;
                }
            }
        }
        return my_r;
    }
};
```
当时自己写的时候，代码逻辑可读性不是很清晰，贴一个清晰的~，不同的是他的是初始化成0，如果能弹空弹出个数就是能看到的个数，不能弹空弹则需要加一。
本质上是一样的，我写的是默认能弹空，如果弹空就会多加一次，可能思路没这么清晰。
```bash
class Solution {
public:
    vector<int> canSeePersonsCount(vector<int>& heights) {
        int n = heights.size();
        vector<int> ret(n);
        stack<int> s;
        for (int i = n - 1; i >= 0; --i) {
            while (!s.empty() && heights[i] >= s.top()) {
                s.pop();
                ret[i]++;
            }
            if (!s.empty()) {
                ret[i]++;
            }
            s.push(heights[i]);
        }
        return ret;
    }
};
```
the end!
