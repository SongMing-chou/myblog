---
title: 第252场周赛
author: 小M
img: /medias/2021.8.2.jpg
# coverImg: /medias/banner/7.jpg
top: false
cover: true
toc: true
date: 2021-08-02 15:37:02
tags: Leetcode
summary: 这次周赛比较偏数学，由于有事没有参加，做了之后虚拟竞赛，也记录一下。
---
这次周赛比较偏数学，由于有事没有参加，做了之后虚拟竞赛，记录一下。

## 第一题(easy)
### [三除数](https://leetcode-cn.com/problems/three-divisors/)
给你一个整数n，如果n恰好有三个正除数，返回true,

没什么好说的，暴力查找也能过
``` bash
class Solution {
public:
    bool isThree(int n) {
        int k=1;
        unordered_set<int> set;
        while(k<=n){
            int temp=0;
            n%k==0?temp=n/k:temp=-1;
            if(temp!=-1){
                set.insert(temp);
            }
            if(set.size()>3)return false;
            k++;
        }
        return set.size()==3;
    }
};
```
优化一下之后
``` bash
class Solution {
    public:
    bool isThree(int n) {
        int i=2;
        for(;i*i<n;i++){
            if(n%i==0)return false;
        }
        return i*i==n;
    }
}
```
## 第二题(Medium)
### [你可以工作的最大周数](https://leetcode-cn.com/problems/maximum-number-of-weeks-for-which-you-can-work/)
给你 n 个项目，编号从 0 到 n - 1 。同时给你一个整数数组 milestones ，其中每个 milestones[i] 表示第 i 个项目中的阶段任务数量。
你可以按下面两个规则参与项目中的工作：
    1.每周，你将会完成 某一个 项目中的 恰好一个 阶段任务。你每周都 必须 工作。
    2.在 连续的 两周中，你 不能 参与并完成同一个项目中的两个阶段任务。
    一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将 停止工作 。注意，由于这些条件的限制，你可能无法完成所有阶段任务。
返回在不违反上面规则的情况下你 最多 能工作多少周。
 .  其实就是不能连续两周做同一个任务，在leetcode上做过一个相似的题[距离相等的条形码](https://leetcode-cn.com/problems/distant-barcodes/)，同样是隔位插入的思想，只要剩下两种以上的工作，总能隔位插入（选取剩余最多和第二多的工作进行隔位插入），此时最大周数就是总任务数sum，当最多的任务nums[i]>sum-nums[i]时，最后就会剩下一种任务，无法进行隔位插入，完成最大周数就是2*(sum-nums[i])+1。
基于以上的想法，可以写出:
``` bash
class Solution {
public:
    long long numberOfWeeks(vector<int>& milestones) {
        sort(milestones.begin(),milestones.end());
        long temp=milestones.back();
        int my_temp=temp;
        long long sum=temp;
        for(int i=0;i<milestones.size()-1;i++){
            sum=sum+milestones[i];
            temp=temp-milestones[i];
        }
        return temp>0?2*(sum-my_temp)+1:sum;
    }
};
```
当初没想那么多，直接排序，其实不用排序就行了
``` bash
class Solution {
public:
    long long numberOfWeeks(vector<int>& milestones) {
        int my_max=0;
        long long sum=0;
        for(int i=0;i<milestones.size();i++){
            sum=sum+milestones[i];
            my_max=max(my_max,milestones[i]);
        }
        return my_max > sum -my_max ? (sum - my_max) * 2 + 1 : sum;
    }
};
```
## 第三题(Medium)
### [收集足够苹果的最小花园周长](https://leetcode-cn.com/problems/minimum-garden-perimeter-to-collect-enough-apples/)
给你一个用无限二维网格表示的花园，每一个 整数坐标处都有一棵苹果树。整数坐标 (i, j) 处的苹果树有 |i| + |j| 个苹果。
你将会买下正中心坐标是 (0, 0) 的一块 正方形土地 ，且每条边都与两条坐标轴之一平行。
给你一个整数 neededApples ，请你返回土地的 最小周长 ，使得 至少 有 neededApples 个苹果在土地 里面或者边缘上。

|x| 的值定义为：
如果 x >= 0 ，那么值为 x
如果 x < 0 ，那么值为 -x

当时以为只要原地点在花园就行了，但其实他的花园总是正方形的。这样题目就简单很多。
![你的花园~](/medias/252.3.jpg)
其实就是找规律，每次变大花园增加的苹果都与顶点有关(最外边一圈），我这里定义point为右上角的坐标x，将花园分成4份，只分析第一步部分。
![](/medias/252.3.1.jpg)
得出有以下特点：
1.平行与x轴为x+1个x苹果(纵坐标)，平行于y轴为x-1个x苹果，增加个数为2x^2；
2.剩下递增部分 平行于y轴为从1递增到x，平行于x轴为从1等增到x,注意这里重复了了一个x，有累加公式2(x+1)x/2-x=x^2
所以你的花园的递推公式就是temp+=12point^2。
分析出来之后就可以写代码了。
```bash
class Solution {
public:
    long long minimumPerimeter(long long neededApples) {
        long long temp=0;
        long long point=0;
        while(temp<neededApples){
            point++;
            # temp=temp+4*(point*(2*point)+point*point);
            temp+=12*point*point;
        }
            return 8*point;
    }
};
```
## 第四题(Hard)
### [统计特殊子序列的数目](https://leetcode-cn.com/problems/count-number-of-special-subsequences/)
特殊序列 是由 正整数 个 0 ，紧接着 正整数 个 1 ，最后 正整数 个 2 组成的序列。

比方说，[0,1,2] 和 [0,0,1,1,1,2] 是特殊序列。
相反，[2,1,0] ，[1] 和 [0,1,2,0] 就不是特殊序列。
给你一个数组 nums （仅 包含整数 0，1 和 2），请你返回 不同特殊子序列的数目 。由于答案可能很大，请你将它对 109 + 7 取余 后返回。

一个数组的 子序列 是从原数组中删除零个或者若干个元素后，剩下元素不改变顺序得到的序列。如果两个子序列的 下标集合 不同，那么这两个子序列是 不同的 。
思路动态规划：
题目只有三种数字0,1,2。我们改变一下思路：分别求0、1、2序列的个数，并且我们规定有效的序列1在序列0之后，有效的序列2在序列1之后，这样序列2个数即为所求。
于是有状态转移方程：
对于nums[i]==0
    则将序列0个数更新为dp[i][0]=2dp[i-1][0]+1;//将上一个0的索引替换成当前的+直接把0加入序列0后面。
对于nums[i]==1
    则将序列1个数更新为dp[i][1]=2dp[i-1][1]+dp[i-1][0]//将上一个1的索引替换成当期+自己当做独立的序列加在序列0后面
对于nums[i]==2
    则将序列2个数更新为dp[i][2]=2dp[i-1][2]+dp[i-1][1]//将上一个2的索引替换成当前+自己当做独立的序列加在序列1后面
有了思路就可以写代码了，因为每次只更新一个状态，另外两个状态不变，故只需要定义三个变量存储f0=dp[i-1][0],f1=dp[i-1][1],f2=dp[i-1][2];
```bash
class Solution {
private:
     #define mod = 1000000007
public:
    int countSpecialSubsequences(vector<int>& nums) {
        int f0 = 0, f1 = 0, f2 = 0;
        for (int num: nums) {
            if (num == 0) {
                f0 = (f0 * 2 + 1) % mod;
            }
            else if (num == 1) {
                f1 = (f1 * 2 % mod + f0) % mod;
            }
            else {
                f2 = (f2 * 2 % mod + f1) % mod;
            }
        }
        return f2;
    }
};
```
the end！
